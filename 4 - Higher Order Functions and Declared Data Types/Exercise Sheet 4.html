<!--?xml version="1.0" encoding="iso-8859-1"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Programming III ( COMP2209 )</title>
  <link href="Exercise%20Sheet%204_files/progiii.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="header">
<h1>Programming III ( COMP 2209 )</h1>
<h1>Semester One, 2017</h1>
<home><a href="https://secure.ecs.soton.ac.uk/notes/comp2209/18-19/index.html">Home</a></home>
</div>

<div class="notes">

<h2>Exercise Sheet Four : Higher-Order Functions and Declared Data Types</h2>

<p>
The aim of this tutorial is for you to gain experience using 
higher-order functions as an abstraction mechanism to encourage code 
reuse via map, filter and fold. It also aims for you to understand the 
use of algebraic data types in Haskell. 
</p>

<p>
Attempt the exercsise in your own time before Tuesday's lab and use that
 session for obtaining feedback and for asking questions related to the 
exercises.
</p>


<exno>Exercise One</exno>
<p>
For each of the following functions give definitions for them using map, filter and/or foldr.
</p><ul>
 <li>Decide if all elements of a list satisfy a predicate<br>
   <tt>all :: (a -&gt; Bool) -&gt; [a] -&gt; Bool</tt>
 </li> 
 <li>Decide if any element of a list satisfies a predicate<br>
 	<tt>any :: (a -&gt; Bool) -&gt; [a] -&gt; Bool</tt>
 </li>
 <li>Select the initial elements from a list while they satisfy a predicate<br>
 	<tt>takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</tt>
 </li>
 <li>Remove the initial elements from a list while they satisfy a predicate<br>
 	<tt>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</tt>
 </li>
</ul>
<p></p>


<exno>Exercise Two</exno>

<p>
Using <tt>foldl</tt> define a function <tt>dec2Int :: [Int] -&gt; Int</tt>
 that takes a list of digits as a representation of a decimal number and
 converts it in to an integer representing that number. For example <tt>dec2Int [1,2,3,4] = 1234</tt>. 
</p>

<exno>Exercise Three</exno>
<p>
Define the higher-order function <tt>curry</tt> that takes a function 
that converts functions on pairs in to their curried form that accept 
their arguments one by one. Conversely, define the function <tt>uncurry</tt> that provides the inverse to this.  Write down the types of these functions first to guide you. 
</p>

<exno>Exercise Four</exno>
<p>
Consider the recursive pattern described by the higher-order function below:
</p><blockquote>
 <pre>  <tt>
    unfold p h t x | p x       = []
                   | otherwise = h x : unfold p h t (t x)
  </tt>
 </pre>
</blockquote>
This is essentially a list generating pattern. The predicate <tt>p</tt> determines the termination condition, the argument <tt>h&gt;</tt> describes how to insert the next element in to the list and <tt>t</tt> describes how the remainder should be processed.<p></p>
<p>
Use <tt>unfold</tt> to define the following functions:
</p><ul>
 <li>
   <tt>int2bin</tt> - that converts an integer to a binary representation as a list of binary digits.	
 </li>
 <li>
 	<tt>chop</tt> - that takes a string and chops it in to a list of strings of a given length.
 </li>
 <li>
 	<tt>map</tt> - the standard map function.
 </li>
 <li>
 	<tt>iterate</tt> - that takes a function <tt>f</tt> and a value <tt>x</tt> and produces the infinite list<br> <tt> [ x, f x , f ( f x) , f ( f ( f x)) , ... ]</tt>
 </li>

</ul>
<p></p>


<exno>Exercise Five</exno>
<p>
Define a function <tt>altMap :: (a -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt; [b]</tt> that accepts two functions and alternately applies them to successive elements in a list.  For example, 
</p>
<pre>  <tt>
    &gt; altMap (+10) (+100) [0,1,2,3,4]
    [10,101,12,103,14]
  </tt>
 </pre>

<exno>Exercise Six</exno>
<p>
Remember the Luhn algorithm from <a href="https://secure.ecs.soton.ac.uk/notes/comp2209/18-19/sheet2.html">Sheet 2</a> Exercise 10 for validating 4-digit bank card numbers?  Now implement this algorithm for bank card numbers of any length.
See if you can define the function <tt>luhn</tt> as a composition <tt>(.)</tt> of functions.
</p>

<exno>Exercise Seven</exno>
<p>
A binary search tree is a tree in which every node contains only smaller
 values in its left subtree and larger values in its right subtree. A 
tree is balanced if the length of every path from the root to each leaf 
differs by at most one.
</p>
<p>
</p><p>
For the given definition of type Tree
</p><blockquote>
  <pre>    <tt>
 data Tree a = Leaf a | Node (Tree a) a (Tree a) deriving Show
    </tt>
  </pre>
</blockquote>
define a function <tt>toTree :: Ord =&gt; [a] -&gt; Tree a</tt> that constructs a balanced, search tree from a given list.
<p></p>

<exno>Exercise Eight</exno>
<p>
Consider the recursive data type
</p><blockquote>
	<pre>		<tt>
 data Nat = Zero | Succ Nat deriving (Eq,Ord,Show,Read)		
		</tt>
	</pre>
</blockquote>
This allows us to represent any natural number as sequences of the successor operation
<blockquote>
	<pre>		<tt>
  Zero
  Succ Zero
  Succ (Succ Zero)
  Succ (Succ (Succ Zero))
  ...		
		</tt>
	</pre>
</blockquote>
Define functions, <tt>even :: Nat -&gt; Bool</tt> and <tt>odd :: Nat -&gt; Bool</tt> that determine whether the given Nat is even or odd. Now define functions <tt>add,mult :: Nat -&gt; Nat -&gt; Nat</tt>
that implement addition and multiplication respectively.
<p></p>



<exno>Exercise Nine</exno>
<p>
Consider a variation on the <tt>Nat</tt> datatype of recursively defined integers. 
We have a successor operation (add one) and a predecessor operation (subtract one).
</p><blockquote>
	<pre>		<tt>
 data RInt = Zero | Succ RInt | Pred RInt deriving Show
		</tt>
	</pre>
</blockquote>
<p></p>
<p>
We say that a value of type <tt>RInt</tt> is in <i>normal</i> form if it does not contain a mix of both <tt>Succ</tt> and <tt>Pred</tt> constructors. 
Write a function <tt>normalise :: RInt -&gt; RInt</tt> that converts any <tt>RInt</tt> value in to a normal form of the same value. 
</p>
<p>
Provide definitions of <tt>odd,even,add,mult</tt> as above for this datatype. You may find it useful to use <tt>normalise</tt> to do this. 
</p>







</div><div class="footer">
Page maintained by Julian Rathke.
</div>
 
</body></html>