<!--?xml version="1.0" encoding="iso-8859-1"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Programming III ( COMP2209 )</title>
  <link href="Exercise%20Sheet%203_files/progiii.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="header">
<h1>Programming III ( COMP 2209 )</h1>
<h1>Semester One, 2017</h1>
<home><a href="https://secure.ecs.soton.ac.uk/notes/comp2209/18-19/index.html">Home</a></home>
</div>

<div class="notes">

<h2>Exercise Sheet 3 : List Comprehension and Recursion</h2>

<p>
The aim of this tutorial is to introduce the iteration operations in 
Haskell. Primarily these consist of list comprehensions and recursively 
defined functions. By the end of this tutorial you should be able to use
 both constructs.
</p>

<p>
Attempt the exercises in your own time before Monday's tutorial and use 
that session for obtaining feedback and for asking questions related to 
the exercises.
</p>


<exno>Exercise One</exno>
<p>
Using a list comprehension, give an expression that calculates the sum of the 
squares of odd numbers and cubes of even numbers for the first 100 integers. 
</p>

<exno>Exercise Two</exno>
<p>
Suppose that a coordinate grid of size m x n is given by the list of all
 pairs (x,y) of integers for 0 &lt;= x &lt;= m and 0 &lt;= y &lt;= n. 
Using a list comprehension, define a function <tt>grid :: Int -&gt; Int -&gt; [(Int,Int)]</tt> that returns a coordinate grid of a given size. For example
</p><blockquote>
<tt>
<pre>&gt; grid 1 2
[(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]
</pre>
</tt>
</blockquote>
<p></p>

<p>Now use a list comprehension to create a function <tt>square :: Int -&gt; [(Int,Int)]</tt> that produces a square grid but excluding the diagonal from (0,0) to (n,n). For example
</p><blockquote>
<tt>
<pre>&gt; square 2
[(0,1), (0,2), (1,0), (1,2), (2,0), (2,1)]
</pre>
</tt>
</blockquote>
<p></p>

<exno>Exercise Three</exno>

<p>
Define the standard library funcion <tt>replicate :: Int -&gt; a -&gt; [a]</tt> using a list comprehension.
</p>

<exno>Exercise Four</exno>
<p>
A triple (x,y,z) of positive integers is <i>Pythagorean</i> if it satisfies the equation 
x^2 + y^2 = z^2. Using a list comprehension with three generators, define a function <tt>pyths :: Int -&gt; [(Int,Int,Int)]</tt> that returns the list of all such triples whose components are at most a given limit. For example
</p><blockquote>
<tt>
<pre>&gt; pyths 10
[(3,4,5), (4,3,5), (6,8,10), (8,6,10)]
</pre>
</tt>
</blockquote>
<p></p>

<exno>Exercise Five</exno>
<p>
A positive integer is <i>perfect</i> if it equals the sum of all of its factors, excluding the number itself. Using a list comprehension and the function <tt>factors</tt>, define a function <tt>perfect :: Int -&gt; [Int]</tt> that returns the list of all perfect numbers up to a given limit. For example
</p><blockquote>
<tt>
<pre>&gt; perfects 500
[6,28,496]
</pre>
</tt>
</blockquote>
<p></p>

<exno>Exercise Six</exno>

Redefine the function <tt>positions :: Eq a =&gt; a -&gt; [a] -&gt; [Int]</tt>
 given in the lecture notes that returns all indexes the given element 
appears at in the given list. However, rather than using a list 
comprehension use the function <tt>find</tt> where
<blockquote><tt><pre>find :: Eq a =&gt; a -&gt; [ (a,b)] -&gt; [b]
find k t = [ v | (k',v) &lt;- t, k==k']
</pre></tt></blockquote>

<exno>Exercise Seven</exno>

<p>
	The <i>scalar product</i> of two lists of integers xs and ys of length n
 is given by the sum of the products of the corresponding integers:  
(x1*y1) + (x2*y2) + ... + (xn*yn). Define a function to calculate the 
scalar product of two lists using a list comprehension.
</p>

<exno>Exercise Eight</exno>

<p>Define a recursive function <tt>sumdown :: Int -&gt; Int-&gt; Int</tt>
 that returns the sum of the non-negative integers from the first given 
value down to the second given value. For example sumdown 7 4 should 
return the result of 7 + 6 + 5 + 4</p>

<exno>Exercise Nine</exno>
<p>
	Define the recursive function <tt>euclid :: Int -&gt; Int -&gt; Int</tt> that implements <i>Euclid's algorithm</i>
 for calculating the greatest common divisor of two non-negative 
integers: if the two numbers are equal, this number is the result, 
otherwise, subtract the small from the larger and repeat. 
</p>

<exno>Exercise Ten</exno>
<p>
	Without using any list sorting functions, write a recursive function <tt>merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]</tt> that merges two sorted lists to give a single sorted list. Now write a function called <tt>mergeSort :: Ord a =&gt; [a] -&gt; [a]</tt> that sorts a list using the merge sort algorithm.
You will find it helpful to define a local function <tt>halve ::[a] -&gt; ([a],[a])</tt> that splits a list in to two halves whose lengths differ by at most one.
</p>


</div><div class="footer">
Page maintained by Julian Rathke.
</div>
 
</body></html>