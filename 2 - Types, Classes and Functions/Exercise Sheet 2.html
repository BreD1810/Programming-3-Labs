<!--?xml version="1.0" encoding="iso-8859-1"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Programming III ( COMP2209 )</title>
  <link href="Exercise%20Sheet%202_files/progiii.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="header">
<h1>Programming III ( COMP 2209 )</h1>
<h1>Semester One, 2018</h1>
<home><a href="https://secure.ecs.soton.ac.uk/notes/comp2209/18-19/index.html">Home</a></home>
</div>

<div class="notes">

<h2>Exercise Sheet Two: Types, Classes and Functions</h2>

<p>
The aim of this tutorial is for you to gain an understanding of types 
and type inference in Haskell. Included in this is the use of 
polymorphic functions and overloaded functions by way of type classes. 
By the end of the tutorial you should also be able to define functions 
using both guarded equations and pattern matching. 
</p>

<p>
Attempt the exercsise in your own time before Tuesday's lab and use that
 session for obtaining feedback and for asking questions related to the 
exercises.
</p>



<exno>Exercise One</exno>

<p>
What are the types (if any) of the following expressions?
</p><blockquote>
<tt>
<pre>['a','b','c']<br>
('a','b','c')<br>
['a',3,True]<br>
('a',3,True)<br>
[ (False, '0'), (True,'1')]<br>
( [True,False] , ['0','1'] )<br>
[tail, init, reverse]<br>
[]<br>
2 : 3 : [] : 4 : 5 : []<br>
[] : []<br>
</pre>
</tt>
</blockquote>
Check your answers using GHCi and the command ":type expr" 
<p></p>

<exno>Exercise Two</exno>
<p>Write down expressions that have the following types:
  </p><blockquote>
    <tt>
      <pre>bools :: [Bool]<br>
nums :: [[Int]]<br>
add :: Int -&gt; Int -&gt; Int -&gt; Int<br>
copy :: a -&gt; (a,a)<br>
apply :: (a -&gt; b) -&gt; a -&gt; b<br>
explode :: String -&gt; [Char]
</pre>
</tt>
</blockquote>
<p></p>

<exno>Exercise Three</exno>
<p>What are the types of the following functions?
  </p><blockquote>
    <tt>
      <pre>second xs = head (tail xs)<br>
swap (x,y) = (y,x)<br>
pair x y = (x,y)<br>
double x = x*2<br>
palindrome xs = reverse xs == xs<br>
twice f x = f ( f x )<br>
</pre>
</tt>
</blockquote>
Take care to include necessary class constraints where appropriate.
<p></p>


<exno>Exercise Four</exno>
<p>
  The class Eq is instantiated by all of the basic types as well as 
Lists and Tuples built from these.  However, function types are not an 
instance of the Eq class.  Suggest reasons why this is the case.
</p> 

<exno>Exercise Five</exno>
<p>
Use library functions that work with List types to define a function <tt>halve :: [a] -&gt; ([a],[a])</tt> that splits an even length list in to two halves. For example 
  <tt>
</tt></p><pre><tt>&gt; halve [1,2,3,4,5,6]
([1,2,3],[4,5,6])
</tt></pre><tt>
</tt>
Can you define this function directly using pattern matching on Lists?
<p></p>

<exno>Exercise Six</exno>
<p>
  Define a function <tt>third :: [a] -&gt; a</tt> that returns the third
 element in a list that contains at least this many elements. Do this 
using the following three techniques:
</p><ul>
  <li><tt>head</tt> and <tt>tail</tt></li>
  <li>list indexing <tt>!!</tt></li>
  <li>pattern matching</li>
</ul>
Think about what to do in the cases where there are fewer than three elements in the list.
<p></p>

<exno>Exercise Seven</exno>
<p>
Consider a function <tt>safetail :: [a] -&gt; [a]</tt> that behaves in the same way as <tt>tail</tt> except that rather than produing an error it returns the empty list in cases where no tail exists. Using <tt>tail</tt> and <tt>null :: [a] -&gt; Bool</tt> that decides whether a list is empty or not, define <tt>safetail</tt> using
</p><ul>
  <li>if-then-else</li>
  <li>guarded equations</li>
  <li>pattern matching</li>
</ul>
For your solutions, which approach produced the most concise code?
<p></p>

<exno>Exercise Eight</exno>
<p>
Define the logical disjunction operator || using pattern matching. Is there more than one way of doing this?
</p>

<exno>Exercise Nine</exno>
<p>
Write a function <tt>enc :: Int -&gt; String -&gt; String</tt> that encrypts a String by adding some given integer to each character's Unicode value. Now, using <tt>enc</tt>
 as a locally declared function write a function that accepts a String 
and an Int and returns a pair of an encrypted string and a function with
 which to decrypt the string.  
</p>

<exno>Exercise Ten</exno>
<p>
The Luhn algorithm is used to check bank card numbers for simple errors such as mistyping a digit. It proceeds as follows:
</p><ul>
  <li>Consider each digit as a separate number</li>
  <li>Moving left, double every other number from the second last</li>
  <li>Subtract 9 from each number that is now greater than 9</li>
  <li>Add all of the resulting numbers together</li>
  <li>If the total is divisible by 10 then card number is valid</li>
</ul>
Define a function <tt>luhnDouble :: Int -&gt; Int</tt> that doubles a digit and subtracts 9 if the result is greater than 9.
Using <tt>luhnDouble</tt> and the function <tt>mod</tt> define a function <tt>luhn :: Int -&gt; Int -&gt; Int -&gt; Int &gt; Bool</tt> that decides whether a four digit card number is is valid. For example 
<blockquote>
  <tt>
    <pre>&gt; luhn 1 7 8 4
True
&gt; luhn 4 7 8 3
False
</pre>
</tt>
</blockquote>
<p></p>

</div><div class="footer">
Page maintained by Julian Rathke.
</div>
 

</body></html>